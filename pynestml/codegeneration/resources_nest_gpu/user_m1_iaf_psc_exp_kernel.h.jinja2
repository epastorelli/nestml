{#-
NeuronHeader_kernel.jinja2

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.
#}
{%- if tracing %}/* generated by {{self._TemplateReference__context.name}} */ {% endif -%}
/**
 *  {{neuronName}}_kernel.h
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  Generated from NESTML at time: {{now}}
**/

#ifndef {{neuronName.upper()}}
#define {{neuronName.upper()}}

// Includes
#include <string>
#include <cmath>

// Includes from NEST GPU:
#include "spike_buffer.h"
#include "node_group.h"
#include "{{neuronName}}.h"

#define MIN(a,b) (((a)<(b))?(a):(b))

extern __constant__ float NESTGPUTimeResolution;

namespace {{neuronName}}_ns
{
	enum ScalVarIndexes
	{
{%-     for variable_name in scalar_variables %}
      {{variable_name}},
{%-     endfor %}
	N_SCAL_VAR
	}

        enum PortVarIndexes
	{
{%-     for variable_name in port_variables %}
      {{variable_name}},
{%-     endfor %}
	N_PORT_VAR
	}

        enum ScalParamIndexes
	{
{%-     for variable_name in scalar_params %}
      {{variable_name}},
{%-     endfor %}
	N_SCAL_PARAM
	}

        enum PortParamIndexes
	{
{%-     for variable_name in port_params %}
      {{variable_name}},
{%-     endfor %}
	N_PORT_PARAM
	}

        enum GroupParamIndexes
	{
{%-     for variable_name in group_params %}
      {{variable_name}},
{%-     endfor %}
	N_GROUP_PARAM
	}

	const std::string {{neuronName}}_scal_var_name[N_SCAL_VAR] = {
{%-     for variable_name in scal_var_name %}
      {{variable_name}},
{%-     endfor %}  	
  	}

	const std::string {{neuronName}}_port_var_name[N_PORT_VAR] = {
{%-     for variable_name in port_var_name %}
      {{variable_name}},
{%-     endfor %}
        }

	const std::string {{neuronName}}_scal_param_name[N_SCAL_PARAM] = {
{%-     for variable_name in scal_param_name %}
      {{variable_name}},
{%-     endfor %}
        }

	const std::string {{neuronName}}_port_param_name[N_PORT_PARAM] = {
{%-     for variable_name in port_param_name %}
      {{variable_name}},
{%-     endfor %}
	}

	const std::string {{neuronName}}_group_param_name[N_GROUP_PARAM] = {
{%-     for variable_name in group_param_name %}
      {{variable_name}},
{%-     endfor %}
	}

#define V_m y[i_V_m]
#define w y[i_w]
#define I_syn(i) y[N_SCAL_VAR + N_PORT_VAR*i + i_I_syn]

#define dVdt dydx[i_V_m]
#define dwdt dydx[i_w]
#define dI_syndt(i) dydx[N_SCAL_VAR + N_PORT_VAR*i + i_I_syn]

#define V_th param[i_V_th]
#define Delta_T param[i_Delta_T]
#define g_L param[i_g_L]
#define E_L param[i_E_L]
#define C_m param[i_C_m]
#define a param[i_a]
#define b param[i_b]
#define tau_w param[i_tau_w]
#define I_e param[i_I_e]
#define V_peak param[i_V_peak]
#define V_reset param[i_V_reset]
#define t_ref param[i_t_ref]
#define refractory_step param[i_refractory_step]
#define den_delay param[i_den_delay]

#define tau_syn(i) param[N_SCAL_PARAM + N_PORT_PARAM*i + i_tau_syn]

#define h_min_rel_ group_param_[i_h_min_rel]
#define h0_rel_ group_param_[i_h0_rel]


 template<int NVAR, int NPARAM> //, class DataStruct>
__device__
    void Derivatives(double x, float *y, float *dydx, float *param,
		     user_m1_rk5 data_struct)
{
  enum { n_port = (NVAR-N_SCAL_VAR)/N_PORT_VAR };
  float I_syn_tot = 0.0;
  

  float V = ( refractory_step > 0 ) ? V_reset :  MIN(V_m, V_peak);
  for (int i = 0; i<n_port; i++) {
    I_syn_tot += I_syn(i);
  }
  float V_spike = Delta_T == 0. ? 0. : Delta_T*exp((V - V_th)/Delta_T);

  dVdt = ( refractory_step > 0 ) ? 0 :
    ( -g_L*(V - E_L - V_spike) + I_syn_tot - w + I_e) / C_m;
  // Adaptation current w.
  dwdt = (a*(V - E_L) - w) / tau_w;
  for (int i=0; i<n_port; i++) {
    // Synaptic current derivative
    dI_syndt(i) = -I_syn(i) / tau_syn(i);
  }
}

 template<int NVAR, int NPARAM> //, class DataStruct>
__device__
    void ExternalUpdate
    (double x, float *y, float *param, bool end_time_step,
			user_m1_rk5 data_struct)
{
  if ( V_m < -1.0e3) { // numerical instability
    printf("V_m out of lower bound\n");
    V_m = V_reset;
    w=0;
    return;
  }
  if ( w < -1.0e6 || w > 1.0e6) { // numerical instability
    printf("w out of bound\n");
    V_m = V_reset;
    w=0;
    return;
  }
  if (refractory_step > 0.0) {
    V_m = V_reset;
    if (end_time_step) {
      refractory_step -= 1.0;
    }
  }
  else {
    if ( V_m >= V_peak ) { // send spike
      int neuron_idx = threadIdx.x + blockIdx.x * blockDim.x;
      PushSpike(data_struct.i_node_0_ + neuron_idx, 1.0);
      V_m = V_reset;
      w += b; // spike-driven adaptation
      refractory_step = (int)round(t_ref/NESTGPUTimeResolution);
      if (refractory_step<0) {
	refractory_step = 0;
      }
    }
  }
}


};

template <>
int user_m1::UpdateNR<0>(long long it, double t1);

template<int N_PORT>
int user_m1::UpdateNR(long long it, double t1)
{
  if (N_PORT == n_port_) {
    const int NVAR = user_m1_ns::N_SCAL_VAR
      + user_m1_ns::N_PORT_VAR*N_PORT;
    const int NPARAM = user_m1_ns::N_SCAL_PARAM
      + user_m1_ns::N_PORT_PARAM*N_PORT;

    rk5_.Update<NVAR, NPARAM>(t1, h_min_, rk5_data_struct_);
  }
  else {
    UpdateNR<N_PORT - 1>(it, t1);
  }

  return 0;
}

template<int NVAR, int NPARAM>
__device__
void Derivatives(double x, float *y, float *dydx, float *param,
		 user_m1_rk5 data_struct)
{
    user_m1_ns::Derivatives<NVAR, NPARAM>(x, y, dydx, param,
						 data_struct);
}

template<int NVAR, int NPARAM>
__device__
void ExternalUpdate(double x, float *y, float *param, bool end_time_step,
		    user_m1_rk5 data_struct)
{
    user_m1_ns::ExternalUpdate<NVAR, NPARAM>(x, y, param,
						    end_time_step,
						    data_struct);
}


#endif